#You Don't Know JS: Async & Performance
## Chapter 3: Promises
在第二章中，我们讨论了使用 callback 作为异步回调的两个主要缺陷。

第一个问题是控制权的问题，有时候我们把程序的控制权交给第三方插件，等待某一个时刻，第三方插件
会调用我们写好的 callback。一般情况下，我们并不会去仔细阅读第三方插件的源码，所以说一般这种
时候，程序的运行并不在我们的掌握之中，（对我来说，这事实在是不太舒服）。

现在有一个替代的选项，可以不交出控制权，取而代之的是当第三方插件完成了它自己的任务之后，返回
一个状态让我们知道，我们自己处理剩下的逻辑，这样听起来是不是就很好了？

Promise 就是干这事的。

Promise 推出就引发了轰动，开发者终于可以不用忍受难看的 “callback hell”。事实上，越来越多的
异步 API 开始建立在 Promise 之上（截至目前，Promise 支持得越来越好，特别是移动端），所以现在
是时候开始学习 Promise 了。

## What Is a Promise?
你有没有过这样的体验，公司要求你学习一门新技术，不管三七二十一，先看源码，看了源码就开始练习，
边练习边体会新技术，很多人都是这么干的（比如说我）。

但是有时候你又会感到非常之困惑，有些技术的 API 实在是太多，太抽象，太枯燥乏味。在你搞懂它具体的思路或者为什么会出现之前，
基本上看源码就处于懵逼的状态。 Promise 就属于这样一门技术。

所以在真正介绍 Promise 之前，原文作者为了帮助大家理解 Promise 的思想，特地举了很多的贴近生活的栗子，让我们一起往下看吧。

### Future Value
因为国情不同，本栗子做了适当的国产化~~

一天中午，你饥肠辘辘，搞完手头的工作后终于可以去吃饭。你来到了最喜欢的黄焖鸡米饭，点了一份大分加辣。

如果不是奸商的话，黄焖鸡米饭当然不会马上送过来（奸商才在一开始就做一大锅给客人吃剩的）。一般情况下，你给钱之后会得到一个号码牌，方便服务员送餐。

这个号码牌就相当于一个 Promise，它是黄焖鸡的凭证。

过个十几分钟，服务员将你的黄焖鸡送过来，拿走了号码牌。

或者服务员过几分钟来告诉你，今儿不好意思，黄焖鸡卖完了，要不来个黄焖排骨？

可见，你拿了号码牌代表未来会有一个结果，这个结果可能好可能坏，可能是黄焖鸡，也可能是黄焖排骨，但不管怎么样，服务员都会来通知你。

### Values Now and Later

你可能觉得上面这个栗子跟你敲代码没有半毛钱关系，没关系，继续往下看。

**Promise 是关于未来的断言**。在真正解释 Promise 之前，我们先回顾下前两章的栗子，温故知新，我们用 callback 导出 Promise 的特性。

想象当你写一个表达式时，比如 + 操作符。其实你已经确定 + 操作符两边的变量都已经时确定值。

``` javaScript
var x, y = 2;

console.log( x + y ); // NaN  <-- because `x` isn't set yet
```
如上所说， 在使用 + 操作符的时候时假设其两边的变量都以确定（resolved）。

如果不是，那就有点奇怪了，假设其中有一个变量是已经确定，而另一个是在未来某一个时候才确定，你能想象 + 操作符会等待另一个值确定的时候再将
两个值相加吗？

又比如说你怎么看待两个值其中有一个或两个都是现在不确定的值，假设第二个值的确定依赖第一个值，如果第一个值确定了之后，第二个值根据第一个值
推倒得出。或者第一个值获取失败，相对的，第二个值也获取失败。

两个值相互依赖，是不是有点像第一章举的栗子？

回到上面这个栗子，我们现在的条件是，执行 x + y。如果 x 或者 y 有一个不确定，请等待其确定了之后再执行相加，你会怎么写代码？（用 callback 的形式）
``` javaScript
function add(getX,getY,cb) {
	var x, y;
	getX( function(xVal){
		x = xVal;
		// both are ready?
		if (y != undefined) {
			cb( x + y );	// send along sum
		}
	} );
	getY( function(yVal){
		y = yVal;
		// both are ready?
		if (x != undefined) {
			cb( x + y );	// send along sum
		}
	} );
}

// `fetchX()` and `fetchY()` are sync or async
// functions
add( fetchX, fetchY, function(sum){
	console.log( sum ); // that was easy, huh?
} );
```
好吧，上面的异步代码看起来比较不优美。我们将 x ，y 都看作是异步的值。而 add(...) 函数并不关心他们是异步还是同步，只有当两个值都确定时，
才会输出他们的和。

甚至可以将 x，y 都看做是异步的值，尽管他们可能是同步值，反正 add(...) 不 care。这样让我们更容易读懂代码。

当然，像上面那样使用基于 callback 的方法处理异步值看起来很粗糙，但是它不妨碍我们理解**像使用同步值一样使用异步值**的优势。

